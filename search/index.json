[{"content":"简介 Spring Expression Language (SpEL) 是强大的表达式语言，支持查询、操作运行时对象图，以及解析逻辑、算术表达式。SpEL可以独立使用，无论是否使用Spring框架。还有一些其他的表达式语言，比如OGNL，可用增强Arthas问题排查。\n示例 解析计算 1 2 3 4 5 ExpressionParser parser = new SpelExpressionParser(); Expression exp = parser.parseExpression(\u0026#34;\u0026#39;Hello World\u0026#39;\u0026#34;); String message = (String) exp.getValue(); // Hello World 基本所有可能用到的SpEL类和接口都在org.springframework.expression和其子包下面，比如spel.support。\nExpressionParser接口用以解析表达式字符串，在上述例子中，表达式串是由单引号'括起来的一个字符串。Expression接口用来计算先前已解析的表达式字符串。在此过程可能抛两种异常，ParseException和\nEvaluationException，分别在parser.parseExpression的时候和exp.getValue()的时候。\nSpEL还可支持调用方法，访问属性，调用构造器等。\n1 2 3 4 5 6 7 8 9 10 11 // Hello World! ExpressionParser parser = new SpelExpressionParser(); Expression exp = parser.parseExpression(\u0026#34;\u0026#39;Hello World\u0026#39;.concat(\u0026#39;!\u0026#39;)\u0026#34;); (1) String message = (String) exp.getValue(); // invokes \u0026#39;getBytes().length\u0026#39; Expression exp = parser.parseExpression(\u0026#34;\u0026#39;Hello World\u0026#39;.bytes.length\u0026#34;); (1) int length = (Integer) exp.getValue(); Expression exp = parser.parseExpression(\u0026#34;new String(\u0026#39;hello world\u0026#39;).toUpperCase()\u0026#34;); String message = exp.getValue(String.class); SpEL 更常见的用法是提供针对特定对象实例（称为根对象）进行j表达式字符串。下面是一个调用构造方法的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Create and set a calendar GregorianCalendar c = new GregorianCalendar(); c.set(1856, 7, 9); // The constructor arguments are name, birthday, and nationality. Inventor tesla = new Inventor(\u0026#34;Nikola Tesla\u0026#34;, c.getTime(), \u0026#34;Serbian\u0026#34;); ExpressionParser parser = new SpelExpressionParser(); Expression exp = parser.parseExpression(\u0026#34;name\u0026#34;); // Parse name as an expression String name = (String) exp.getValue(tesla); // name == \u0026#34;Nikola Tesla\u0026#34; exp = parser.parseExpression(\u0026#34;name == \u0026#39;Nikola Tesla\u0026#39;\u0026#34;); boolean result = exp.getValue(tesla, Boolean.class); 应用 Bean Definitions 可以通过XML和注解两种方式来进行使用，语法都是#{ \u0026lt;expression string\u0026gt; }\nXML 1 2 3 \u0026lt;bean id=\u0026#34;numberGuess\u0026#34; class=\u0026#34;org.spring.samples.NumberGuess\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;randomNumber\u0026#34; value=\u0026#34;#{ T(java.lang.Math).random() * 100.0 }\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 应用程序上下文中的所有Bean都可以作为预定义的变量，以其共同的Bean名称来使用。这包括标准的上下文Bean，如environment（类型为org.springframework.core.env.Environment），以及用于访问运行时环境的systemProperties和systemEnvironment（类型为Map\u0026lt;String, Object\u0026gt;）。注意：不必在这里用#符号给预定义的变量加前缀。\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;bean id=\u0026#34;taxCalculator\u0026#34; class=\u0026#34;org.spring.samples.TaxCalculator\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;defaultLocale\u0026#34; value=\u0026#34;#{ systemProperties[\u0026#39;user.region\u0026#39;] }\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; // numberGuess \u0026lt;bean id=\u0026#34;numberGuess\u0026#34; class=\u0026#34;org.spring.samples.NumberGuess\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;randomNumber\u0026#34; value=\u0026#34;#{ T(java.lang.Math).random() * 100.0 }\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; // 引用其他bean \u0026lt;bean id=\u0026#34;shapeGuess\u0026#34; class=\u0026#34;org.spring.samples.ShapeGuess\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;initialShapeSeed\u0026#34; value=\u0026#34;#{ numberGuess.randomNumber }\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; Annotation 常用的@Value注解实可使用SpEL表达式：\n1 2 @Value(\u0026#34;#{ systemProperties[\u0026#39;user.region\u0026#39;] }\u0026#34;) private String defaultLocale; 参考语法 Literal Expressions 支持下列几种：\nstrings numeric values: integer (intor long), hexadecimal (intor long), real (floator double) boolean values: trueor false null 1 2 3 4 // evaluates to \u0026#34;Tony\u0026#39;s Pizza\u0026#34; String pizzaParlor = (String) parser.parseExpression(\u0026#34;\u0026#39;Tony\u0026#39;\u0026#39;s Pizza\u0026#39;\u0026#34;).getValue(); double avogadrosNumber = (Double) parser.parseExpression(\u0026#34;6.0221415E+23\u0026#34;).getValue(); Properties, Arrays, Lists, Maps, and Indexers 属性首字母不区分大小写，下例也可表示为Birthdate.Year + 1900\n1 2 // evaluates to 1856 int year = (Integer) parser.parseExpression(\u0026#34;birthdate.year + 1900\u0026#34;).getValue(context); 数组和列表的内容是通过使用[]获得的，如下例所示：\n1 2 3 4 5 6 7 8 9 // Officer\u0026#39;s Dictionary Inventor pupin = parser.parseExpression(\u0026#34;officers[\u0026#39;president\u0026#39;]\u0026#34;).getValue( societyContext, Inventor.class); // evaluates to \u0026#34;Idvor\u0026#34; String city = parser.parseExpression(\u0026#34;officers[\u0026#39;president\u0026#39;].placeOfBirth.city\u0026#34;).getValue( societyContext, String.class); // setting values parser.parseExpression(\u0026#34;officers[\u0026#39;advisors\u0026#39;][0].placeOfBirth.country\u0026#34;).setValue( societyContext, \u0026#34;Croatia\u0026#34;); Inline Lists 可以直接通过{}来表示lists\n1 2 3 4 // evaluates to a Java list containing the four numbers List numbers = (List) parser.parseExpression(\u0026#34;{1,2,3,4}\u0026#34;).getValue(context); List listOfLists = (List) parser.parseExpression(\u0026#34;{{\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;},{\u0026#39;x\u0026#39;,\u0026#39;y\u0026#39;}}\u0026#34;).getValue(context); Inline Maps 可以直接通过{key:value}来表示maps，{:}表示一个空的map。\n1 Map inventorInfo = (Map) parser.parseExpression(\u0026#34;{name:\u0026#39;Nikola\u0026#39;,dob:\u0026#39;10-July-1856\u0026#39;}\u0026#34;).getValue(context); Array Construction（数组构造） 1 2 3 4 5 6 7 int[] numbers1 = (int[]) parser.parseExpression(\u0026#34;new int[4]\u0026#34;).getValue(context); // Array with initializer int[] numbers2 = (int[]) parser.parseExpression(\u0026#34;new int[]{1,2,3}\u0026#34;).getValue(context); // Multi dimensional array int[][] numbers3 = (int[][]) parser.parseExpression(\u0026#34;new int[4][5]\u0026#34;).getValue(context); Methods（方法调用） 可以通过常规的Java语法来进行方法调用：\n1 2 3 4 5 6 // string literal, evaluates to \u0026#34;bc\u0026#34; String bc = parser.parseExpression(\u0026#34;\u0026#39;abc\u0026#39;.substring(1, 3)\u0026#34;).getValue(String.class); // evaluates to true boolean isMember = parser.parseExpression(\u0026#34;isMember(\u0026#39;Mihajlo Pupin\u0026#39;)\u0026#34;).getValue( societyContext, Boolean.class); Operators（运算符） 类型 操作符 算术运算 +, -, *, /, %, ^, div, mod 关系运算 \u0026lt;, \u0026gt;, ==, !=, \u0026lt;=, \u0026gt;=, lt, gt, eq, ne, le, ge 逻辑运算 and, or, not, \u0026amp;\u0026amp;, ||, ! 条件运算 ?: 正则 matches 1 2 3 4 5 6 7 8 9 10 11 // evaluates to true boolean trueValue = parser.parseExpression(\u0026#34;2 == 2\u0026#34;).getValue(Boolean.class); // evaluates to false boolean falseValue = parser.parseExpression(\u0026#34;2 \u0026lt; -5.0\u0026#34;).getValue(Boolean.class); // evaluates to true boolean trueValue = parser.parseExpression(\u0026#34;\u0026#39;black\u0026#39; \u0026lt; \u0026#39;block\u0026#39;\u0026#34;).getValue(Boolean.class); // uses CustomValue:::compareTo boolean trueValue = parser.parseExpression(\u0026#34;new CustomValue(1) \u0026lt; new CustomValue(2)\u0026#34;).getValue(Boolean.class); 注意： 当大于小于与null进行比较的时候，遵循这么一个规则：null相当于什么都没有，所以所有值都大于null,任意值都不小于null，即x \u0026gt; null永远为true，x \u0026lt; null永远为false.\n1 2 3 4 5 6 7 8 9 10 11 // evaluates to false boolean falseValue = parser.parseExpression( \u0026#34;\u0026#39;xyz\u0026#39; instanceof T(Integer)\u0026#34;).getValue(Boolean.class); // evaluates to true boolean trueValue = parser.parseExpression( \u0026#34;\u0026#39;5.00\u0026#39; matches \u0026#39;^-?\\\\d+(\\\\.\\\\d{2})?$\u0026#39;\u0026#34;).getValue(Boolean.class); // evaluates to false boolean falseValue = parser.parseExpression( \u0026#34;\u0026#39;5.0067\u0026#39; matches \u0026#39;^-?\\\\d+(\\\\.\\\\d{2})?$\u0026#39;\u0026#34;).getValue(Boolean.class); 注意： 原始类型要小心，因为它们会立即被装箱到它们的包装类型上。1 instanceof T(int)等于false，1 instanceof T(Integer)等于true\n1 2 3 4 5 6 7 // evaluates to false boolean falseValue = parser.parseExpression(\u0026#34;true and false\u0026#34;).getValue(Boolean.class); // evaluates to true boolean trueValue = parser.parseExpression(\u0026#34;true or false\u0026#34;).getValue(Boolean.class); // -- AND and NOT -- String expression = \u0026#34;isMember(\u0026#39;Nikola Tesla\u0026#39;) and !isMember(\u0026#39;Mihajlo Pupin\u0026#39;)\u0026#34;; boolean falseValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class); 数学运算符 +号可用于数字和字符，-``*``/``%``^仅能用于数字，同时保持正常的运算优先级\n1 2 3 4 5 6 7 8 9 10 11 12 13 // Addition int two = parser.parseExpression(\u0026#34;1 + 1\u0026#34;).getValue(Integer.class); // 2 String testString = parser.parseExpression( \u0026#34;\u0026#39;test\u0026#39; + \u0026#39; \u0026#39; + \u0026#39;string\u0026#39;\u0026#34;).getValue(String.class); // \u0026#39;test string\u0026#39; // Subtraction int four = parser.parseExpression(\u0026#34;1 - -3\u0026#34;).getValue(Integer.class); // 4 double d = parser.parseExpression(\u0026#34;1000.00 - 1e4\u0026#34;).getValue(Double.class); // -9000 // Multiplication int six = parser.parseExpression(\u0026#34;-2 * -3\u0026#34;).getValue(Integer.class); // 6 赋值运算符 =与setValue等价\n1 2 3 4 5 6 7 8 Inventor inventor = new Inventor(); EvaluationContext context = SimpleEvaluationContext.forReadWriteDataBinding().build(); parser.parseExpression(\u0026#34;name\u0026#34;).setValue(context, inventor, \u0026#34;Aleksandar Seovic\u0026#34;); // alternatively String aleks = parser.parseExpression( \u0026#34;name = \u0026#39;Aleksandar Seovic\u0026#39;\u0026#34;).getValue(context, inventor, String.class); Types 你可以使用特殊的T操作符来指定一个java.lang.Class（类型）的实例。静态方法也是通过使用这个操作符来调用的。StandardEvaluationContext使用TypeLocator来寻找类型，而StandardTypeLocator（可以被替换）是在了解java.lang包的情况下建立的。这意味着对java.lang包内类型的T()引用不需要完全限定，但所有其他类型的引用必须限定。\n1 2 3 4 5 6 7 Class dateClass = parser.parseExpression(\u0026#34;T(java.util.Date)\u0026#34;).getValue(Class.class); Class stringClass = parser.parseExpression(\u0026#34;T(String)\u0026#34;).getValue(Class.class); boolean trueValue = parser.parseExpression( \u0026#34;T(java.math.RoundingMode).CEILING \u0026lt; T(java.math.RoundingMode).FLOOR\u0026#34;) .getValue(Boolean.class); Constructors 可以通过new调用构造器方法，如果不是java.lang包中的类，需要使用完整的类名\n1 2 3 4 // create new Inventor instance within the add() method of List p.parseExpression( \u0026#34;Members.add(new org.spring.samples.spel.inventor.Inventor( \u0026#39;Albert Einstein\u0026#39;, \u0026#39;German\u0026#39;))\u0026#34;).getValue(societyContext); Variables（变量） 通过#variables的形式来引用变量，通过在EvaluationContext上setVariable可以设置变量\n1 2 3 4 5 6 7 Inventor tesla = new Inventor(\u0026#34;Nikola Tesla\u0026#34;, \u0026#34;Serbian\u0026#34;); EvaluationContext context = SimpleEvaluationContext.forReadWriteDataBinding().build(); context.setVariable(\u0026#34;newName\u0026#34;, \u0026#34;Mike Tesla\u0026#34;); parser.parseExpression(\u0026#34;name = #newName\u0026#34;).getValue(context, tesla); System.out.println(tesla.getName()) // \u0026#34;Mike Tesla\u0026#34; 通过#this引用当前对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 // create an array of integers List\u0026lt;Integer\u0026gt; primes = new ArrayList\u0026lt;Integer\u0026gt;(); primes.addAll(Arrays.asList(2,3,5,7,11,13,17)); // create parser and set variable \u0026#39;primes\u0026#39; as the array of integers ExpressionParser parser = new SpelExpressionParser(); EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataAccess(); context.setVariable(\u0026#34;primes\u0026#34;, primes); // all prime numbers \u0026gt; 10 from the list (using selection ?{...}) // evaluates to [11, 13, 17] List\u0026lt;Integer\u0026gt; primesGreaterThanTen = (List\u0026lt;Integer\u0026gt;) parser.parseExpression( \u0026#34;#primes.?[#this\u0026gt;10]\u0026#34;).getValue(context); Functions（自定义函数） 通过EvaluationContext可以注册自定义的方法\n1 2 3 4 Method method = ...; EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build(); context.setVariable(\u0026#34;myFunction\u0026#34;, method); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public abstract class StringUtils { public static String reverseString(String input) { StringBuilder backwards = new StringBuilder(input.length()); for (int i = 0; i \u0026lt; input.length(); i++) { backwards.append(input.charAt(input.length() - 1 - i)); } return backwards.toString(); } } ExpressionParser parser = new SpelExpressionParser(); EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build(); context.setVariable(\u0026#34;reverseString\u0026#34;, StringUtils.class.getDeclaredMethod(\u0026#34;reverseString\u0026#34;, String.class)); String helloWorldReversed = parser.parseExpression( \u0026#34;#reverseString(\u0026#39;hello\u0026#39;)\u0026#34;).getValue(context, String.class); Bean References（Bean引用） 如果evaluation context中已经配置过bean解析器，可以使用@来查找beans\n1 2 3 4 5 6 ExpressionParser parser = new SpelExpressionParser(); StandardEvaluationContext context = new StandardEvaluationContext(); context.setBeanResolver(new MyBeanResolver()); // This will end up calling resolve(context,\u0026#34;something\u0026#34;) on MyBeanResolver during evaluation Object bean = parser.parseExpression(\u0026#34;@something\u0026#34;).getValue(context); 如果需要factory bean，需要用\u0026amp;\n1 2 3 4 5 6 ExpressionParser parser = new SpelExpressionParser(); StandardEvaluationContext context = new StandardEvaluationContext(); context.setBeanResolver(new MyBeanResolver()); // This will end up calling resolve(context,\u0026#34;\u0026amp;foo\u0026#34;) on MyBeanResolver during evaluation Object bean = parser.parseExpression(\u0026#34;\u0026amp;foo\u0026#34;).getValue(context); Ternary Operator (If-Then-Else)（三目运算） 1 2 3 4 5 6 7 8 9 parser.parseExpression(\u0026#34;name\u0026#34;).setValue(societyContext, \u0026#34;IEEE\u0026#34;); societyContext.setVariable(\u0026#34;queryName\u0026#34;, \u0026#34;Nikola Tesla\u0026#34;); expression = \u0026#34;isMember(#queryName)? #queryName + \u0026#39; is a member of the \u0026#39; \u0026#34; + \u0026#34;+ Name + \u0026#39; Society\u0026#39; : #queryName + \u0026#39; is not a member of the \u0026#39; + Name + \u0026#39; Society\u0026#39;\u0026#34;; String queryResultString = parser.parseExpression(expression) .getValue(societyContext, String.class); // queryResultString = \u0026#34;Nikola Tesla is a member of the IEEE Society\u0026#34; The Elvis Operator 简化版的三目运算符\n1 2 3 4 5 6 7 8 9 10 11 12 13 ExpressionParser parser = new SpelExpressionParser(); EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build(); Inventor tesla = new Inventor(\u0026#34;Nikola Tesla\u0026#34;, \u0026#34;Serbian\u0026#34;); String name = parser.parseExpression(\u0026#34;name?:\u0026#39;Elvis Presley\u0026#39;\u0026#34;).getValue(context, tesla, String.class); System.out.println(name); // Nikola Tesla tesla.setName(null); name = parser.parseExpression(\u0026#34;name?:\u0026#39;Elvis Presley\u0026#39;\u0026#34;).getValue(context, tesla, String.class); System.out.println(name); // Elvis Presley @Value(\u0026#34;#{systemProperties[\u0026#39;pop3.port\u0026#39;] ?: 25}\u0026#34;) // 如果定义了pops.port则取其值，否则取25 Safe Navigation Operator 从Groovy中吸取过来为了避免出现空指针的情况，js中也存在类似语法\n1 2 3 4 5 6 7 8 9 10 11 12 ExpressionParser parser = new SpelExpressionParser(); EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build(); Inventor tesla = new Inventor(\u0026#34;Nikola Tesla\u0026#34;, \u0026#34;Serbian\u0026#34;); tesla.setPlaceOfBirth(new PlaceOfBirth(\u0026#34;Smiljan\u0026#34;)); String city = parser.parseExpression(\u0026#34;placeOfBirth?.city\u0026#34;).getValue(context, tesla, String.class); System.out.println(city); // Smiljan tesla.setPlaceOfBirth(null); city = parser.parseExpression(\u0026#34;placeOfBirth?.city\u0026#34;).getValue(context, tesla, String.class); System.out.println(city); // null - does not throw NullPointerException!!! Collection Selection（集合选择器） Selection是一种强大的表达式功能，可让您通过从其条目中进行选择来将源集合转换为另一个集合。其语法为.?[selectionExpression]，支持只要实现了java.lang.Iterable或者java.util.Map的类。\n1 2 3 4 List\u0026lt;Inventor\u0026gt; list = (List\u0026lt;Inventor\u0026gt;) parser.parseExpression( \u0026#34;members.?[nationality == \u0026#39;Serbian\u0026#39;]\u0026#34;).getValue(societyContext); Map newMap = parser.parseExpression(\u0026#34;map.?[value\u0026lt;27]\u0026#34;).getValue(); 如果获取首个匹配的元素语法为.^[selectionExpression]，获取最后一个语法为.$[selectionExpression]\nCollection Projection 集合映射，相当于从一个集合中通过子表达式获得一个新的集合。语法为.![projectionExpression]：\n1 2 // returns [\u0026#39;Smiljan\u0026#39;, \u0026#39;Idvor\u0026#39; ] List placesOfBirth = (List)parser.parseExpression(\u0026#34;members.![placeOfBirth.city]\u0026#34;); Expression templating（表达式模板） 表达式模板可以混合普通字符串和其他解析表达式模块，每一个块都用#{}来进行区分：\n1 2 3 4 5 String randomPhrase = parser.parseExpression( \u0026#34;random number is #{T(java.lang.Math).random()}\u0026#34;, new TemplateParserContext()).getValue(String.class); // evaluates to \u0026#34;random number is 0.7038186818312008\u0026#34; parseExpression()方法的第二个参数是 ParserContext 类型。ParserContext接口被用来影响表达式的解析方式，以支持表达式模板化功能。TemplateParserContext是这么定义的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class TemplateParserContext implements ParserContext { public String getExpressionPrefix() { return \u0026#34;#{\u0026#34;; } public String getExpressionSuffix() { return \u0026#34;}\u0026#34;; } public boolean isTemplate() { return true; } } 源码分析 总结 SpEL是一种功能强大、支持良好的表达式语言，可以在Spring组合的所有产品中使用。我们可以用它来配置Spring应用程序，也可以用它来编写解析器，以便在任何应用程序中执行更普遍的任务。\n参考文档 SpEL官方文档地址：Spring Expression Language Spring Expression Language Guide ","date":"2024-01-07T21:45:35+08:00","permalink":"https://billguo.cc/p/spel%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0/","title":"Spel表达式学习"},{"content":"登入系统获取一个shell进程时，读取环境变量有几步：\n首先读入全局变量 /etc/profile，然后根据其内容读取额外的设定的文档，如 /etc/profile.d和/etc/inputrc 然后根据不同用户读取~路径下.bash_profile，如果这读取不了就读取~/.bash_login，这个也读取不了才会读取~/.profile，这三个文档设定基本上是一样的，读取有优先关系 然后根据用户账号读取~/.bashrc 其他\n~/.profile可以设定本用户专有的路径，环境变量等，它只在登入的时候执行一次\n~/.bashrc也是某用户专有设定文档，可以设定路径，设置alias，每次shell script的执行都会使用它一次\n","date":"2022-04-14T23:16:42+08:00","permalink":"https://billguo.cc/p/linux-profile%E4%BC%98%E5%85%88%E7%BA%A7/","title":"Linux profile优先级"},{"content":"我的2019 时间过得很快，一晃在杭州已经快三年半了。感觉这几年就没怎么好好总结过自己的工作和生活。从今年开始还是好好做一下这件事情，在脑子里边空想，和用文字记录下来始终是不一样的。回顾下过去，也给明年定一下目标，而不是单纯的mv 2019-todo.txt 2020-todo.txt。\n工作 先说说工作上的事情。\n本来年初的时候开始着手进行新系统的开发任务，使用的技术栈也是目前市场上相对比较主流的，这样自己的所学刚好能够有输出的地方。Spring Boot和Spring Cloud的相关组件，以前只是自己写着玩，现在总算能付诸在实际的产品中了。中间还搞了一段时间的Vue组件的封装，做了一下前端组件的自动生成框架。但是好景不长，没做多久就由于组织架构调整，又把我调回去了。又回到以前Spring MVC，写Oracle存储过程的日子。好刀不磨会生锈，技术学了不用，也是会忘记的。\n还好自己的相关工作也不是业务强相关的，也自己找了一些事情来做。包括老产品几个微服务的拆分，设计和实现，中间也学到了不少东西。倒也不是全无收获。\n生活 生活上可以说是糟透了。\n工作中的不如意确实是会一点点影响生活的。由于最近一两年都疏于锻炼，身体状态可以说每况愈下。九月份的时候，突发了阑尾炎。由于一些原因当时又不能做手术，连续挂了好几天的水。今年以来，肠胃也是频频出问题，确实影响平时的状态，而且还带有轻微的焦虑症，也是来来去去跑了好几次医院。这种状态真的让人后背发凉，一个是身体上的折磨，一个是心理的焦虑。年纪轻轻，但是却像个几十岁的老人，没有朝气，自己想想也觉得可怕。\n明年的打算 回去割掉阑尾，检查一下肠胃，每天无论多忙也要适量运动。身体是革命的本钱，确实不是没有道理的。身体不断地给出警告，还不引起重视肯定不行。 多阅读源码。这段时间以来，进步缓慢，不只是身体的原因，也有自己懈怠的原因。之前定好了什么什么计划，实际落实的却没有多少，明年争取有所改变。 Java相关的技术栈，几种MicroService或者Serveless的解决方案都了解一下。 刷刷LeetCode，算法和数据结构不多多练习，忘记得太快了。 还有就是，写博客的这个习惯，以前我也经常写这个东西，但是记录下的东西感觉都是写皮毛，或者搞些很基础的东西，就相当于在制造垃圾，不怎么整理然后就删掉了。现在想想，其实放到自己的博客里边又有什么关系呢，反正也没人来看，就当自己的笔记好了。 每年其实也阅读了不少书籍，不管是技术类的还是社科类的，后面也单独弄一个文档记录下来，有些重要的可以用思维导图的方式自己终结归纳一下。学而时习之，不亦说乎？ ","date":"2019-12-28T14:26:29+08:00","permalink":"https://billguo.cc/p/%E6%88%91%E7%9A%842019/","title":"我的2019"},{"content":"Base64背景 维基百科的解释 Base64是一种基于64个可打印字符来表示二进制数据的表示方法。由于2^6^=64，所以每6个bit为一个单元，对应某个可打印字符。3个字节有24个bit，对应于4个Base64单元，即3个字节可由4个可打印字符来表示。它可用来作为电子邮件的传输编码。在Base64中的可打印字符包括字母A-Z、a-z、数字0-9，这样共有62个字符，此外两个可打印符号在不同的系统中而不同。\n由来及场景 在参数传输的过程中经常遇到的一种情况：使用全英文的没问题，但一旦涉及到中文就会出现乱码情况。与此类似，网络上传输的字符并不全是可打印的字符，比如二进制文件、图片等。Base64的出现就是为了解决此问题，它是基于64个可打印的字符来表示二进制的数据的一种方法。\n电子邮件刚问世的时候，只能传输英文，但后来随着用户的增加，中文、日文等文字的用户也有需求，但这些字符并不能被服务器或网关有效处理，因此Base64就登场了。随之，Base64在URL、Cookie、网页传输少量二进制文件中也有相应的使用。\n通常使用的字符 使用的字符包括大小写英文字母各26个、数字10个、加号+和斜杠/，共64个字符，等号=用来作为后缀用途。\n算法简介 编码过程 通常情况 将待编码的字符串中各个字母的ASCII码查出. 将ASCII码转化为8位2进制表示，如文本M的ASCII码为77，用二进制表示则为01001101. 由于每6个bit为一个单元，所以每6个二进制位转化成一个十进制数，即编码结果的ASCII码. 如010011计算可得19. 转化所有编码结果即可. 当字节不能被3整除时: 当无法被整除时，base64要在后面添加\\0凑齐3n位，使二进制序列的长度成为24的倍数(6和8的最小公倍数). 由于不断补0,对应产生的空字符将用等号=填充，所以等号的个数必为0个，1个或2个. 其他场景\n标准的Base64并不适合直接放在URL里传输，因为URL编码器会把标准Base64中的/和+字符变为形如%XX的形式，而这些%号在存入数据库时还需要再进行转换，因为ANSI SQL中已将%号用作通配符。\n1 2 3 4 5 6 import base64 encode_str = base64.b64encode(\u0026#39;ac\u0026gt;\u0026#39;.encode(\u0026#39;utf-8\u0026#39;)) print(\u0026#34;result: \u0026#34;, encode_str) url_safe_encode_str = base64.urlsafe_b64encode(\u0026#39;ac\u0026gt;\u0026#39;.encode(\u0026#39;utf-8\u0026#39;)) print(\u0026#34;result: \u0026#34;, url_safe_encode_str) 运行结果：\n1 2 3 4 5 [Running] python -u \u0026#34;d:\\urlsafe.py\u0026#34; result: b\u0026#39;YWM+\u0026#39; result: b\u0026#39;YWM-\u0026#39; [Done] exited with code=0 in 0.424 seconds 解码过程 去掉末尾的等号=。剩下的Base64字符，每8bit组成一个8bit字节，最后剩余不足8位的丢弃.\n总结 一般来说，由于使用base64编码后的长度通常是原字符长度的4/3倍. 其实在补0的问题上，我也疑惑过为什么要一直补到24的倍数. 实际上这样做不仅是实现上的问题，而且当两个编码结果进行拼接之后，解码过程也能顺利进行.这样一想，应该就能很好理解了.\n","date":"2019-07-10T23:00:29+08:00","permalink":"https://billguo.cc/p/base64%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/","title":"Base64编码原理探究"},{"content":"Sublime Text3 常用的一些快捷键操作：包括跳转，编辑，选择，查找等。\nGoto Anything (Navigation) Goto Anything: Ctrl + P Goto Symbol: Ctrl + R Goto Line: Ctrl + G Editing text Insert line before / after - Ctrl + Shift + Return / Ctrl + Return Copy line / Paste from history - Ctrl + C / Ctrl + K, Ctrl + V Delete to beginning / end - Ctrl + Shift + Backspace / Ctrl + K Delete / Cut a line - Ctrl + Shift + K / Ctrl + X Soft Undo / Redo - Ctrl + U / Ctrl + Shift + U Upper / lower case - Ctrl + K, Ctrl + U / Ctrl + K, Ctrl + L Joining Lines - Ctrl + J Bubble the line up / down - Ctrl + Shift + up / Ctrl + Shift + down Sort a line - F9 Duplicating a line - Ctrl + Shift + D Indent - Unindent - Ctrl + ], Ctrl + [ Commenting a line - Ctrl + / Close HTML tag - Alt + . Wrap line at ruler - Alt + Q Transpose - Ctrl + T Selection Multiple selection - Ctrl + clicks at multiple places Column Selection - Ctrl + Alt + Up or Ctrl + Alt + Down / Esc for going back to single Split block of selection into multiple lines - Ctrl + Shift + L Select word with multiple occurrences - Ctrl + D Quick skip - Ctrl + K, Ctrl + D Selecting a line - Ctrl + L Expand selection to brackets - Ctrl + Shift + M Expand selection to indentation - Ctrl + Shift + J Expand selection to scope - Ctrl + Shift + Space Navigation Goto symbol in project - Ctrl + Shift + R Goto definition - F12 Goto beginning / end of a line - Home / End Goto matching bracket - Ctrl + M Move back / forward in history - Alt + - / Alt + Shift + - Code fold / unfold - Ctrl + Shift + [ / Ctrl + Shift + ] Find Find - Ctrl + F Find next - F3 Find previous - Shift + F3 Find all - Alt + Return (while find window is open) Use selection to find - Ctrl + E Incremental find - Ctrl + I Incremental find previous - Ctrl + Shift + I Find all with incremental find - Alt + Return (while the panel is open) Replace panel - Ctrl + H Replace next - Ctrl + Shift + H Replace all - Ctrl + Alt + Return (Only when replace panel is open) Add selection to replace - Ctrl + Shift + E Quick find - Ctrl + F3 Quick find previous - Ctrl + Shift + F3 Quick find all - Alt + F3 Find in project - Ctrl + Shift + F Others Opening User settings - ^ + , Python Console - ^ + Backticks Command Palette - Ctrl + Shift + P ","date":"2016-09-16T20:43:44Z","permalink":"https://billguo.cc/p/sublime-text3-%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/","title":"sublime text3 常用快捷键"},{"content":"全排列问题，指假如给定字符串，输出所有子串可能的排列的问题。解法比较多，递归非递归都可以。\n深度优先搜素（Depth First Search,DFS) 搜索算法的一种。是沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点 v 的所在边都己被探寻过，搜索将回溯到发现节点 v 的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于盲目搜索。\nDFS 的基本模型：\n1 2 3 4 5 6 7 8 void dfs(int step) { 判断边界 尝试每一种可能 for(i=1;i\u0026lt;=n;i++) { 继续下一步 dfs(step+1); } return; } 关键代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 bool dfs(string \u0026amp;bunch, int bLen, string str) { if (bLen == str.length()) { // } string::size_type i; for (i = 0; i \u0026lt; bLen; ++i) { if (!vis[i]) { vis[i] = true; str += bunch[i]; if (dfs(bunch, bLen, str)) { return true; } vis[i] = false; str = str.substr(0, str.length() - 1); } } // End of for return false; } 全排列问题还有很多种变形问题，比如涉及去重等等。后面再具体补充。\n","date":"2015-08-11T14:52:17+08:00","permalink":"https://billguo.cc/p/%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%981/","title":"全排列问题(1)"}]