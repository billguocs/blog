[{"content":"登入系统获取一个shell进程时，读取环境变量有几步：\n首先读入全局变量 /etc/profile，然后根据其内容读取额外的设定的文档，如 /etc/profile.d和/etc/inputrc 然后根据不同用户读取~路径下.bash_profile，如果这读取不了就读取~/.bash_login，这个也读取不了才会读取~/.profile，这三个文档设定基本上是一样的，读取有优先关系 然后根据用户账号读取~/.bashrc 其他\n~/.profile可以设定本用户专有的路径，环境变量等，它只在登入的时候执行一次\n~/.bashrc也是某用户专有设定文档，可以设定路径，设置alias，每次shell script的执行都会使用它一次\n","date":"2022-04-14T23:16:42+08:00","permalink":"https://billguo.cc/p/linux-profile%E4%BC%98%E5%85%88%E7%BA%A7/","title":"Linux profile优先级"},{"content":"我的2019 时间过得很快，一晃在杭州已经快三年半了。感觉这几年就没怎么好好总结过自己的工作和生活。从今年开始还是好好做一下这件事情，在脑子里边空想，和用文字记录下来始终是不一样的。回顾下过去，也给明年定一下目标，而不是单纯的mv 2019-todo.txt 2020-todo.txt。\n工作 先说说工作上的事情。\n本来年初的时候开始着手进行新系统的开发任务，使用的技术栈也是目前市场上相对比较主流的，这样自己的所学刚好能够有输出的地方。Spring Boot和Spring Cloud的相关组件，以前只是自己写着玩，现在总算能付诸在实际的产品中了。中间还搞了一段时间的Vue组件的封装，做了一下前端组件的自动生成框架。但是好景不长，没做多久就由于组织架构调整，又把我调回去了。又回到以前Spring MVC，写Oracle存储过程的日子。好刀不磨会生锈，技术学了不用，也是会忘记的。\n还好自己的相关工作也不是业务强相关的，也自己找了一些事情来做。包括老产品几个微服务的拆分，设计和实现，中间也学到了不少东西。倒也不是全无收获。\n生活 生活上可以说是糟透了。\n工作中的不如意确实是会一点点影响生活的。由于最近一两年都疏于锻炼，身体状态可以说每况愈下。九月份的时候，突发了阑尾炎。由于一些原因当时又不能做手术，连续挂了好几天的水。今年以来，肠胃也是频频出问题，确实影响平时的状态，而且还带有轻微的焦虑症，也是来来去去跑了好几次医院。这种状态真的让人后背发凉，一个是身体上的折磨，一个是心理的焦虑。年纪轻轻，但是却像个几十岁的老人，没有朝气，自己想想也觉得可怕。\n明年的打算 回去割掉阑尾，检查一下肠胃，每天无论多忙也要适量运动。身体是革命的本钱，确实不是没有道理的。身体不断地给出警告，还不引起重视肯定不行。 多阅读源码。这段时间以来，进步缓慢，不只是身体的原因，也有自己懈怠的原因。之前定好了什么什么计划，实际落实的却没有多少，明年争取有所改变。 Java相关的技术栈，几种MicroService或者Serveless的解决方案都了解一下。 刷刷LeetCode，算法和数据结构不多多练习，忘记得太快了。 还有就是，写博客的这个习惯，以前我也经常写这个东西，但是记录下的东西感觉都是写皮毛，或者搞些很基础的东西，就相当于在制造垃圾，不怎么整理然后就删掉了。现在想想，其实放到自己的博客里边又有什么关系呢，反正也没人来看，就当自己的笔记好了。 每年其实也阅读了不少书籍，不管是技术类的还是社科类的，后面也单独弄一个文档记录下来，有些重要的可以用思维导图的方式自己终结归纳一下。学而时习之，不亦说乎？ ","date":"2019-12-28T14:26:29+08:00","permalink":"https://billguo.cc/p/%E6%88%91%E7%9A%842019/","title":"我的2019"},{"content":"Base64背景 维基百科的解释 Base64是一种基于64个可打印字符来表示二进制数据的表示方法。由于2^6^=64，所以每6个bit为一个单元，对应某个可打印字符。3个字节有24个bit，对应于4个Base64单元，即3个字节可由4个可打印字符来表示。它可用来作为电子邮件的传输编码。在Base64中的可打印字符包括字母A-Z、a-z、数字0-9，这样共有62个字符，此外两个可打印符号在不同的系统中而不同。\n由来及场景 在参数传输的过程中经常遇到的一种情况：使用全英文的没问题，但一旦涉及到中文就会出现乱码情况。与此类似，网络上传输的字符并不全是可打印的字符，比如二进制文件、图片等。Base64的出现就是为了解决此问题，它是基于64个可打印的字符来表示二进制的数据的一种方法。\n电子邮件刚问世的时候，只能传输英文，但后来随着用户的增加，中文、日文等文字的用户也有需求，但这些字符并不能被服务器或网关有效处理，因此Base64就登场了。随之，Base64在URL、Cookie、网页传输少量二进制文件中也有相应的使用。\n通常使用的字符 使用的字符包括大小写英文字母各26个、数字10个、加号+和斜杠/，共64个字符，等号=用来作为后缀用途。\n算法简介 编码过程 通常情况 将待编码的字符串中各个字母的ASCII码查出. 将ASCII码转化为8位2进制表示，如文本M的ASCII码为77，用二进制表示则为01001101. 由于每6个bit为一个单元，所以每6个二进制位转化成一个十进制数，即编码结果的ASCII码. 如010011计算可得19. 转化所有编码结果即可. 当字节不能被3整除时: 当无法被整除时，base64要在后面添加\\0凑齐3n位，使二进制序列的长度成为24的倍数(6和8的最小公倍数). 由于不断补0,对应产生的空字符将用等号=填充，所以等号的个数必为0个，1个或2个. 其他场景\n标准的Base64并不适合直接放在URL里传输，因为URL编码器会把标准Base64中的/和+字符变为形如%XX的形式，而这些%号在存入数据库时还需要再进行转换，因为ANSI SQL中已将%号用作通配符。\n1 2 3 4 5 6 import base64 encode_str = base64.b64encode(\u0026#39;ac\u0026gt;\u0026#39;.encode(\u0026#39;utf-8\u0026#39;)) print(\u0026#34;result: \u0026#34;, encode_str) url_safe_encode_str = base64.urlsafe_b64encode(\u0026#39;ac\u0026gt;\u0026#39;.encode(\u0026#39;utf-8\u0026#39;)) print(\u0026#34;result: \u0026#34;, url_safe_encode_str) 运行结果：\n1 2 3 4 5 [Running] python -u \u0026#34;d:\\urlsafe.py\u0026#34; result: b\u0026#39;YWM+\u0026#39; result: b\u0026#39;YWM-\u0026#39; [Done] exited with code=0 in 0.424 seconds 解码过程 去掉末尾的等号=。剩下的Base64字符，每8bit组成一个8bit字节，最后剩余不足8位的丢弃.\n总结 一般来说，由于使用base64编码后的长度通常是原字符长度的4/3倍. 其实在补0的问题上，我也疑惑过为什么要一直补到24的倍数. 实际上这样做不仅是实现上的问题，而且当两个编码结果进行拼接之后，解码过程也能顺利进行.这样一想，应该就能很好理解了.\n","date":"2019-07-10T23:00:29+08:00","permalink":"https://billguo.cc/p/base64%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/","title":"Base64编码原理探究"},{"content":"Sublime Text3 常用的一些快捷键操作：包括跳转，编辑，选择，查找等。\nGoto Anything (Navigation) Goto Anything: Ctrl + P Goto Symbol: Ctrl + R Goto Line: Ctrl + G Editing text Insert line before / after - Ctrl + Shift + Return / Ctrl + Return Copy line / Paste from history - Ctrl + C / Ctrl + K, Ctrl + V Delete to beginning / end - Ctrl + Shift + Backspace / Ctrl + K Delete / Cut a line - Ctrl + Shift + K / Ctrl + X Soft Undo / Redo - Ctrl + U / Ctrl + Shift + U Upper / lower case - Ctrl + K, Ctrl + U / Ctrl + K, Ctrl + L Joining Lines - Ctrl + J Bubble the line up / down - Ctrl + Shift + up / Ctrl + Shift + down Sort a line - F9 Duplicating a line - Ctrl + Shift + D Indent - Unindent - Ctrl + ], Ctrl + [ Commenting a line - Ctrl + / Close HTML tag - Alt + . Wrap line at ruler - Alt + Q Transpose - Ctrl + T Selection Multiple selection - Ctrl + clicks at multiple places Column Selection - Ctrl + Alt + Up or Ctrl + Alt + Down / Esc for going back to single Split block of selection into multiple lines - Ctrl + Shift + L Select word with multiple occurrences - Ctrl + D Quick skip - Ctrl + K, Ctrl + D Selecting a line - Ctrl + L Expand selection to brackets - Ctrl + Shift + M Expand selection to indentation - Ctrl + Shift + J Expand selection to scope - Ctrl + Shift + Space Navigation Goto symbol in project - Ctrl + Shift + R Goto definition - F12 Goto beginning / end of a line - Home / End Goto matching bracket - Ctrl + M Move back / forward in history - Alt + - / Alt + Shift + - Code fold / unfold - Ctrl + Shift + [ / Ctrl + Shift + ] Find Find - Ctrl + F Find next - F3 Find previous - Shift + F3 Find all - Alt + Return (while find window is open) Use selection to find - Ctrl + E Incremental find - Ctrl + I Incremental find previous - Ctrl + Shift + I Find all with incremental find - Alt + Return (while the panel is open) Replace panel - Ctrl + H Replace next - Ctrl + Shift + H Replace all - Ctrl + Alt + Return (Only when replace panel is open) Add selection to replace - Ctrl + Shift + E Quick find - Ctrl + F3 Quick find previous - Ctrl + Shift + F3 Quick find all - Alt + F3 Find in project - Ctrl + Shift + F Others Opening User settings - ^ + , Python Console - ^ + Backticks Command Palette - Ctrl + Shift + P ","date":"2016-09-16T20:43:44Z","permalink":"https://billguo.cc/p/sublime-text3-%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/","title":"sublime text3 常用快捷键"},{"content":"全排列问题，指假如给定字符串，输出所有子串可能的排列的问题。解法比较多，递归非递归都可以。\n深度优先搜素（Depth First Search,DFS) 搜索算法的一种。是沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点 v 的所在边都己被探寻过，搜索将回溯到发现节点 v 的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于盲目搜索。\nDFS 的基本模型：\n1 2 3 4 5 6 7 8 void dfs(int step) { 判断边界 尝试每一种可能 for(i=1;i\u0026lt;=n;i++) { 继续下一步 dfs(step+1); } return; } 关键代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 bool dfs(string \u0026amp;bunch, int bLen, string str) { if (bLen == str.length()) { // } string::size_type i; for (i = 0; i \u0026lt; bLen; ++i) { if (!vis[i]) { vis[i] = true; str += bunch[i]; if (dfs(bunch, bLen, str)) { return true; } vis[i] = false; str = str.substr(0, str.length() - 1); } } // End of for return false; } 全排列问题还有很多种变形问题，比如涉及去重等等。后面再具体补充。\n","date":"2015-08-11T14:52:17+08:00","permalink":"https://billguo.cc/p/%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%981/","title":"全排列问题(1)"}]