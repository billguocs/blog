<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Development on Bill&#39;s Thought</title>
        <link>https://billguo.cc/categories/development/</link>
        <description>Recent content in Development on Bill&#39;s Thought</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Thu, 14 Apr 2022 23:16:42 +0800</lastBuildDate><atom:link href="https://billguo.cc/categories/development/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Linux profile优先级</title>
        <link>https://billguo.cc/post/linux/linux-profile/</link>
        <pubDate>Thu, 14 Apr 2022 23:16:42 +0800</pubDate>
        
        <guid>https://billguo.cc/post/linux/linux-profile/</guid>
        <description>&lt;p&gt;登入系统获取一个shell进程时，读取环境变量有几步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先读入全局变量 &lt;code&gt;/etc/profile&lt;/code&gt;，然后根据其内容读取额外的设定的文档，如 &lt;code&gt;/etc/profile.d&lt;/code&gt;和&lt;code&gt;/etc/inputrc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;然后根据不同用户读取&lt;code&gt;~&lt;/code&gt;路径下&lt;code&gt;.bash_profile&lt;/code&gt;，如果这读取不了就读取&lt;code&gt;~/.bash_login&lt;/code&gt;，这个也读取不了才会读取&lt;code&gt;~/.profile&lt;/code&gt;，这三个文档设定基本上是一样的，读取有优先关系&lt;/li&gt;
&lt;li&gt;然后根据用户账号读取&lt;code&gt;~/.bashrc&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;其他&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;
&lt;code&gt;~/.profile&lt;/code&gt;可以设定本用户专有的路径，环境变量等，它只在登入的时候执行一次&lt;!-- raw HTML omitted --&gt;&lt;code&gt;~/.bashrc&lt;/code&gt;也是某用户专有设定文档，可以设定路径，命令别名，每次shell script的执行都会使用它一次&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Base64编码原理探究</title>
        <link>https://billguo.cc/post/tech/base64/</link>
        <pubDate>Wed, 10 Jul 2019 23:00:29 +0800</pubDate>
        
        <guid>https://billguo.cc/post/tech/base64/</guid>
        <description>&lt;h4 id=&#34;base64背景&#34;&gt;Base64背景&lt;/h4&gt;
&lt;h5 id=&#34;维基百科的解释&#34;&gt;维基百科的解释&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Base64&lt;/strong&gt;是一种基于64个可打印字符来表示二进制数据的表示方法。由于2^6^=64，所以每6个bit为一个单元，对应某个可打印字符。3个字节有24个bit，对应于4个Base64单元，即3个字节可由4个可打印字符来表示。它可用来作为电子邮件的传输编码。在Base64中的可打印字符包括字母&lt;code&gt;A-Z&lt;/code&gt;、&lt;code&gt;a-z&lt;/code&gt;、数字&lt;code&gt;0-9&lt;/code&gt;，这样共有62个字符，此外两个可打印符号在不同的系统中而不同。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;由来及场景&#34;&gt;由来及场景&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;在参数传输的过程中经常遇到的一种情况：使用全英文的没问题，但一旦涉及到中文就会出现乱码情况。与此类似，网络上传输的字符并不全是可打印的字符，比如二进制文件、图片等。Base64的出现就是为了解决此问题，它是基于64个可打印的字符来表示二进制的数据的一种方法。&lt;/p&gt;
&lt;p&gt;电子邮件刚问世的时候，只能传输英文，但后来随着用户的增加，中文、日文等文字的用户也有需求，但这些字符并不能被服务器或网关有效处理，因此Base64就登场了。随之，Base64在URL、Cookie、网页传输少量二进制文件中也有相应的使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;通常使用的字符&#34;&gt;通常使用的字符&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;使用的字符包括大小写英文字母各26个、数字10个、加号&lt;code&gt;+&lt;/code&gt;和斜杠&lt;code&gt;/&lt;/code&gt;，共64个字符，等号&lt;code&gt;=&lt;/code&gt;用来作为后缀用途。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;算法简介&#34;&gt;算法简介&lt;/h4&gt;
&lt;h5 id=&#34;编码过程&#34;&gt;编码过程&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;通常情况&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/08/19/wAI6OgLye95bpvM.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1565001808032.png&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将待编码的字符串中各个字母的ASCII码查出.&lt;/li&gt;
&lt;li&gt;将ASCII码转化为8位2进制表示，如文本&lt;em&gt;M&lt;/em&gt;的ASCII码为&lt;code&gt;77&lt;/code&gt;，用二进制表示则为&lt;code&gt;01001101&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;由于每6个bit为一个单元，所以每6个二进制位转化成一个十进制数，即编码结果的ASCII码. 如&lt;code&gt;010011&lt;/code&gt;计算可得&lt;code&gt;19&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;转化所有编码结果即可.&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;当字节不能被3整除时:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/08/19/NVT13aJqrZpcfzy.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1565001979601.png&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当无法被整除时，base64要在后面添加&lt;code&gt;\0&lt;/code&gt;凑齐&lt;code&gt;3n&lt;/code&gt;位，使二进制序列的长度成为&lt;code&gt;24&lt;/code&gt;的倍数(6和8的最小公倍数).&lt;/li&gt;
&lt;li&gt;由于不断补&lt;code&gt;0&lt;/code&gt;,对应产生的空字符将用等号&lt;code&gt;=&lt;/code&gt;填充，所以等号的个数必为0个，1个或2个.&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;其他场景&lt;/p&gt;
&lt;p&gt;标准的Base64并不适合直接放在URL里传输，因为URL编码器会把标准Base64中的&lt;code&gt;/&lt;/code&gt;和&lt;code&gt;+&lt;/code&gt;字符变为形如&lt;code&gt;%XX&lt;/code&gt;的形式，而这些&lt;code&gt;%&lt;/code&gt;号在存入数据库时还需要再进行转换，因为ANSI SQL中已将&lt;code&gt;%&lt;/code&gt;号用作通配符。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; base64

encode_str &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; base64&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;b64encode(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;ac&amp;gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;encode(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;utf-8&amp;#39;&lt;/span&gt;))
print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;result: &amp;#34;&lt;/span&gt;, encode_str)
url_safe_encode_str &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; base64&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;urlsafe_b64encode(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;ac&amp;gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;encode(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;utf-8&amp;#39;&lt;/span&gt;))
print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;result: &amp;#34;&lt;/span&gt;, url_safe_encode_str)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;Running&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; python -u &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;d:\urlsafe.py&amp;#34;&lt;/span&gt;
result:  b&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;YWM+&amp;#39;&lt;/span&gt;
result:  b&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;YWM-&amp;#39;&lt;/span&gt;

&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;Done&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; exited with code&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; in 0.424 seconds
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;解码过程&#34;&gt;解码过程&lt;/h5&gt;
&lt;p&gt;去掉末尾的等号&lt;code&gt;=&lt;/code&gt;。剩下的Base64字符，每8bit组成一个8bit字节，最后剩余不足8位的丢弃.&lt;/p&gt;
&lt;h4 id=&#34;总结&#34;&gt;总结&lt;/h4&gt;
&lt;p&gt;一般来说，由于使用base64编码后的长度通常是原字符长度的&lt;code&gt;4/3&lt;/code&gt;倍.
&lt;!-- raw HTML omitted --&gt;其实在补&lt;code&gt;0&lt;/code&gt;的问题上，我也疑惑过为什么要一直补到&lt;code&gt;24&lt;/code&gt;的倍数. 实际上这样做不仅是实现上的问题，而且当两个编码结果进行拼接之后，解码过程也能顺利进行.这样一想，应该就能很好理解了.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>全排列问题(1)</title>
        <link>https://billguo.cc/post/tech/dfs/</link>
        <pubDate>Tue, 11 Aug 2015 14:52:17 +0800</pubDate>
        
        <guid>https://billguo.cc/post/tech/dfs/</guid>
        <description>&lt;p&gt;全排列问题，指假如给定字符串，输出所有子串可能的排列的问题。解法比较多，递归非递归都可以。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;深度优先搜素（Depth First Search,DFS)
搜索算法的一种。是沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点 v 的所在边都己被探寻过，搜索将回溯到发现节点 v 的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于盲目搜索。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;DFS 的基本模型：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dfs&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; step)
{
    &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;判断边界&lt;/span&gt;
    &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;尝试每一种可能&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt;n;i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
        &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;继续下一步&lt;/span&gt; dfs(step&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;关键代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dfs&lt;/span&gt;(string &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;bunch, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; bLen, string str)
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (bLen &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; str.length()) {
            &lt;span style=&#34;color:#75715e&#34;&gt;//
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    }

    string&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;size_type i;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; bLen; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;vis[i]) {
            vis[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; true;
            str &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; bunch[i];
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (dfs(bunch, bLen, str)) {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; true;
            }
            vis[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; false;
            str &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; str.substr(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, str.length() &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
        }
    }   &lt;span style=&#34;color:#75715e&#34;&gt;// End of for
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; false;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;p&gt;全排列问题还有很多种变形问题，比如涉及去重等等。后面再具体补充。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
