<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>base64 on Bill&#39;s Thought</title>
        <link>https://billguo.cc/tags/base64/</link>
        <description>Recent content in base64 on Bill&#39;s Thought</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Wed, 10 Jul 2019 23:00:29 +0800</lastBuildDate><atom:link href="https://billguo.cc/tags/base64/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Base64编码原理探究</title>
        <link>https://billguo.cc/post/tech/base64/</link>
        <pubDate>Wed, 10 Jul 2019 23:00:29 +0800</pubDate>
        
        <guid>https://billguo.cc/post/tech/base64/</guid>
        <description>&lt;h4 id=&#34;base64背景&#34;&gt;Base64背景&lt;/h4&gt;
&lt;h5 id=&#34;维基百科的解释&#34;&gt;维基百科的解释&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Base64&lt;/strong&gt;是一种基于64个可打印字符来表示二进制数据的表示方法。由于2^6^=64，所以每6个bit为一个单元，对应某个可打印字符。3个字节有24个bit，对应于4个Base64单元，即3个字节可由4个可打印字符来表示。它可用来作为电子邮件的传输编码。在Base64中的可打印字符包括字母&lt;code&gt;A-Z&lt;/code&gt;、&lt;code&gt;a-z&lt;/code&gt;、数字&lt;code&gt;0-9&lt;/code&gt;，这样共有62个字符，此外两个可打印符号在不同的系统中而不同。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;由来及场景&#34;&gt;由来及场景&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;在参数传输的过程中经常遇到的一种情况：使用全英文的没问题，但一旦涉及到中文就会出现乱码情况。与此类似，网络上传输的字符并不全是可打印的字符，比如二进制文件、图片等。Base64的出现就是为了解决此问题，它是基于64个可打印的字符来表示二进制的数据的一种方法。&lt;/p&gt;
&lt;p&gt;电子邮件刚问世的时候，只能传输英文，但后来随着用户的增加，中文、日文等文字的用户也有需求，但这些字符并不能被服务器或网关有效处理，因此Base64就登场了。随之，Base64在URL、Cookie、网页传输少量二进制文件中也有相应的使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;通常使用的字符&#34;&gt;通常使用的字符&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;使用的字符包括大小写英文字母各26个、数字10个、加号&lt;code&gt;+&lt;/code&gt;和斜杠&lt;code&gt;/&lt;/code&gt;，共64个字符，等号&lt;code&gt;=&lt;/code&gt;用来作为后缀用途。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;算法简介&#34;&gt;算法简介&lt;/h4&gt;
&lt;h5 id=&#34;编码过程&#34;&gt;编码过程&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;通常情况&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/08/19/wAI6OgLye95bpvM.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1565001808032.png&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将待编码的字符串中各个字母的ASCII码查出.&lt;/li&gt;
&lt;li&gt;将ASCII码转化为8位2进制表示，如文本&lt;em&gt;M&lt;/em&gt;的ASCII码为&lt;code&gt;77&lt;/code&gt;，用二进制表示则为&lt;code&gt;01001101&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;由于每6个bit为一个单元，所以每6个二进制位转化成一个十进制数，即编码结果的ASCII码. 如&lt;code&gt;010011&lt;/code&gt;计算可得&lt;code&gt;19&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;转化所有编码结果即可.&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;当字节不能被3整除时:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/08/19/NVT13aJqrZpcfzy.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1565001979601.png&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当无法被整除时，base64要在后面添加&lt;code&gt;\0&lt;/code&gt;凑齐&lt;code&gt;3n&lt;/code&gt;位，使二进制序列的长度成为&lt;code&gt;24&lt;/code&gt;的倍数(6和8的最小公倍数).&lt;/li&gt;
&lt;li&gt;由于不断补&lt;code&gt;0&lt;/code&gt;,对应产生的空字符将用等号&lt;code&gt;=&lt;/code&gt;填充，所以等号的个数必为0个，1个或2个.&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;其他场景&lt;/p&gt;
&lt;p&gt;标准的Base64并不适合直接放在URL里传输，因为URL编码器会把标准Base64中的&lt;code&gt;/&lt;/code&gt;和&lt;code&gt;+&lt;/code&gt;字符变为形如&lt;code&gt;%XX&lt;/code&gt;的形式，而这些&lt;code&gt;%&lt;/code&gt;号在存入数据库时还需要再进行转换，因为ANSI SQL中已将&lt;code&gt;%&lt;/code&gt;号用作通配符。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; base64

encode_str &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; base64&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;b64encode(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;ac&amp;gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;encode(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;utf-8&amp;#39;&lt;/span&gt;))
print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;result: &amp;#34;&lt;/span&gt;, encode_str)
url_safe_encode_str &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; base64&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;urlsafe_b64encode(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;ac&amp;gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;encode(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;utf-8&amp;#39;&lt;/span&gt;))
print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;result: &amp;#34;&lt;/span&gt;, url_safe_encode_str)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;Running&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; python -u &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;d:\urlsafe.py&amp;#34;&lt;/span&gt;
result:  b&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;YWM+&amp;#39;&lt;/span&gt;
result:  b&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;YWM-&amp;#39;&lt;/span&gt;

&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;Done&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; exited with code&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; in 0.424 seconds
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;解码过程&#34;&gt;解码过程&lt;/h5&gt;
&lt;p&gt;去掉末尾的等号&lt;code&gt;=&lt;/code&gt;。剩下的Base64字符，每8bit组成一个8bit字节，最后剩余不足8位的丢弃.&lt;/p&gt;
&lt;h4 id=&#34;总结&#34;&gt;总结&lt;/h4&gt;
&lt;p&gt;一般来说，由于使用base64编码后的长度通常是原字符长度的&lt;code&gt;4/3&lt;/code&gt;倍.
&lt;!-- raw HTML omitted --&gt;其实在补&lt;code&gt;0&lt;/code&gt;的问题上，我也疑惑过为什么要一直补到&lt;code&gt;24&lt;/code&gt;的倍数. 实际上这样做不仅是实现上的问题，而且当两个编码结果进行拼接之后，解码过程也能顺利进行.这样一想，应该就能很好理解了.&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
