<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>base64 on Bill's Thought</title><link>https://billguo.cc/tags/base64/</link><description>Recent content in base64 on Bill's Thought</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 10 Jul 2019 23:00:29 +0800</lastBuildDate><atom:link href="https://billguo.cc/tags/base64/index.xml" rel="self" type="application/rss+xml"/><item><title>Base64编码原理探究</title><link>https://billguo.cc/p/base64%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/</link><pubDate>Wed, 10 Jul 2019 23:00:29 +0800</pubDate><guid>https://billguo.cc/p/base64%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/</guid><description>&lt;h4 id="base64背景">Base64背景&lt;/h4>
&lt;h5 id="维基百科的解释">维基百科的解释&lt;/h5>
&lt;blockquote>
&lt;p>&lt;strong>Base64&lt;/strong>是一种基于64个可打印字符来表示二进制数据的表示方法。由于2^6^=64，所以每6个bit为一个单元，对应某个可打印字符。3个字节有24个bit，对应于4个Base64单元，即3个字节可由4个可打印字符来表示。它可用来作为电子邮件的传输编码。在Base64中的可打印字符包括字母&lt;code>A-Z&lt;/code>、&lt;code>a-z&lt;/code>、数字&lt;code>0-9&lt;/code>，这样共有62个字符，此外两个可打印符号在不同的系统中而不同。&lt;/p>
&lt;/blockquote>
&lt;h5 id="由来及场景">由来及场景&lt;/h5>
&lt;blockquote>
&lt;p>在参数传输的过程中经常遇到的一种情况：使用全英文的没问题，但一旦涉及到中文就会出现乱码情况。与此类似，网络上传输的字符并不全是可打印的字符，比如二进制文件、图片等。Base64的出现就是为了解决此问题，它是基于64个可打印的字符来表示二进制的数据的一种方法。&lt;/p>
&lt;p>电子邮件刚问世的时候，只能传输英文，但后来随着用户的增加，中文、日文等文字的用户也有需求，但这些字符并不能被服务器或网关有效处理，因此Base64就登场了。随之，Base64在URL、Cookie、网页传输少量二进制文件中也有相应的使用。&lt;/p>
&lt;/blockquote>
&lt;h5 id="通常使用的字符">通常使用的字符&lt;/h5>
&lt;blockquote>
&lt;p>使用的字符包括大小写英文字母各26个、数字10个、加号&lt;code>+&lt;/code>和斜杠&lt;code>/&lt;/code>，共64个字符，等号&lt;code>=&lt;/code>用来作为后缀用途。&lt;/p>
&lt;/blockquote>
&lt;h4 id="算法简介">算法简介&lt;/h4>
&lt;h5 id="编码过程">编码过程&lt;/h5>
&lt;ul>
&lt;li>通常情况&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://i.loli.net/2019/08/19/wAI6OgLye95bpvM.png"
loading="lazy"
alt="1565001808032.png"
>&lt;/p>
&lt;ol>
&lt;li>将待编码的字符串中各个字母的ASCII码查出.&lt;/li>
&lt;li>将ASCII码转化为8位2进制表示，如文本&lt;em>M&lt;/em>的ASCII码为&lt;code>77&lt;/code>，用二进制表示则为&lt;code>01001101&lt;/code>.&lt;/li>
&lt;li>由于每6个bit为一个单元，所以每6个二进制位转化成一个十进制数，即编码结果的ASCII码. 如&lt;code>010011&lt;/code>计算可得&lt;code>19&lt;/code>.&lt;/li>
&lt;li>转化所有编码结果即可.&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>当字节不能被3整除时:&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://i.loli.net/2019/08/19/NVT13aJqrZpcfzy.png"
loading="lazy"
alt="1565001979601.png"
>&lt;/p>
&lt;ol>
&lt;li>当无法被整除时，base64要在后面添加&lt;code>\0&lt;/code>凑齐&lt;code>3n&lt;/code>位，使二进制序列的长度成为&lt;code>24&lt;/code>的倍数(6和8的最小公倍数).&lt;/li>
&lt;li>由于不断补&lt;code>0&lt;/code>,对应产生的空字符将用等号&lt;code>=&lt;/code>填充，所以等号的个数必为0个，1个或2个.&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>
&lt;p>其他场景&lt;/p>
&lt;p>标准的Base64并不适合直接放在URL里传输，因为URL编码器会把标准Base64中的&lt;code>/&lt;/code>和&lt;code>+&lt;/code>字符变为形如&lt;code>%XX&lt;/code>的形式，而这些&lt;code>%&lt;/code>号在存入数据库时还需要再进行转换，因为ANSI SQL中已将&lt;code>%&lt;/code>号用作通配符。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">base64&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">encode_str&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">base64&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">b64encode&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;ac&amp;gt;&amp;#39;&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">encode&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;utf-8&amp;#39;&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;result: &amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">encode_str&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">url_safe_encode_str&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">base64&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">urlsafe_b64encode&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;ac&amp;gt;&amp;#39;&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">encode&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;utf-8&amp;#39;&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;result: &amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">url_safe_encode_str&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>运行结果：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Running&lt;span class="o">]&lt;/span> python -u &lt;span class="s2">&amp;#34;d:\urlsafe.py&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">result: b&lt;span class="s1">&amp;#39;YWM+&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">result: b&lt;span class="s1">&amp;#39;YWM-&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Done&lt;span class="o">]&lt;/span> exited with &lt;span class="nv">code&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">0&lt;/span> in 0.424 seconds
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;h5 id="解码过程">解码过程&lt;/h5>
&lt;p>去掉末尾的等号&lt;code>=&lt;/code>。剩下的Base64字符，每8bit组成一个8bit字节，最后剩余不足8位的丢弃.&lt;/p>
&lt;h4 id="总结">总结&lt;/h4>
&lt;p>一般来说，由于使用base64编码后的长度通常是原字符长度的&lt;code>4/3&lt;/code>倍.
&lt;br>其实在补&lt;code>0&lt;/code>的问题上，我也疑惑过为什么要一直补到&lt;code>24&lt;/code>的倍数. 实际上这样做不仅是实现上的问题，而且当两个编码结果进行拼接之后，解码过程也能顺利进行.这样一想，应该就能很好理解了.&lt;/p></description></item></channel></rss>